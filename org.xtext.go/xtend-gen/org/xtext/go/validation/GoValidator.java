/**
 * generated by Xtext 2.13.0
 */
package org.xtext.go.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.go.go.Atrib;
import org.xtext.go.go.AtribVar;
import org.xtext.go.go.CallFunc;
import org.xtext.go.go.DecFunc;
import org.xtext.go.go.DecVar;
import org.xtext.go.go.Decl;
import org.xtext.go.go.GoPackage;
import org.xtext.go.go.Greeting;
import org.xtext.go.go.Numbers;
import org.xtext.go.go.Params;
import org.xtext.go.go.TypeValue;
import org.xtext.go.go.Variable;
import org.xtext.go.validation.AbstractGoValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GoValidator extends AbstractGoValidator {
  public final static String SEMANTIC_ERROR = "Erro Semântico: ";
  
  public static Map<String, DecFunc> funcImplements = new HashMap<String, DecFunc>();
  
  public static Map<String, DecVar> variablesDeclarationMap = new HashMap<String, DecVar>();
  
  @Check
  public void checkGreetingStartsWithCapital(final AtribVar g) {
    int _size = g.getAtrb().size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      int _size_1 = g.getVars().size();
      int _size_2 = g.getAtrb().size();
      boolean _lessThan = (_size_1 < _size_2);
      if (_lessThan) {
        this.error("número de atribuições maior que variaveis", GoPackage.Literals.DEC_VARS__VARS);
      } else {
        int _size_3 = g.getVars().size();
        int _size_4 = g.getAtrb().size();
        boolean _greaterThan_1 = (_size_3 > _size_4);
        if (_greaterThan_1) {
          this.error("número de atribuições menor que variaveis", GoPackage.Literals.DEC_VARS__VARS);
        }
      }
    }
  }
  
  public boolean checkIfCallFuncIdExists(final String funcName) {
    boolean out = false;
    DecFunc arr = GoValidator.funcImplements.get(funcName);
    boolean _notEquals = (!Objects.equal(arr, null));
    if (_notEquals) {
      out = true;
    }
    return out;
  }
  
  /**
   * This function add in the map all the variables in the source code
   */
  @Check
  public DecVar addVariableDeclarations(final DecVar dec) {
    DecVar _xifexpression = null;
    AtribVar _assignment = dec.getAssignment();
    if ((_assignment instanceof Decl)) {
      this.addAtribVarInMap(dec.getAssignment());
    } else {
      DecVar _xifexpression_1 = null;
      Decl _declaration = dec.getDeclaration();
      if ((_declaration instanceof AtribVar)) {
        _xifexpression_1 = this.addDeclarionVarInMap(dec.getDeclaration());
      } else {
        DecVar _xifexpression_2 = null;
        Atrib _atribuicao = dec.getAtribuicao();
        if ((_atribuicao instanceof Atrib)) {
          _xifexpression_2 = this.addAtribuicaoVarInMap(dec.getAtribuicao());
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public void addAtribVarInMap(final AtribVar atrib) {
    EList<String> _vars = atrib.getVars();
    for (final String id : _vars) {
      GoValidator.variablesDeclarationMap.put(id.toString(), ((DecVar) atrib));
    }
  }
  
  public DecVar addDeclarionVarInMap(final Decl dec) {
    return GoValidator.variablesDeclarationMap.put(dec.getName().toString(), ((DecVar) dec));
  }
  
  public DecVar addAtribuicaoVarInMap(final Atrib dec) {
    DecVar _xblockexpression = null;
    {
      this.checkTypeDeclarationAtrib(dec);
      _xblockexpression = GoValidator.variablesDeclarationMap.put(dec.getName().toString(), ((DecVar) dec));
    }
    return _xblockexpression;
  }
  
  public void checkTypeDeclarationAtrib(final Atrib dec) {
    Greeting _atrib = dec.getAtrib();
    if ((_atrib instanceof TypeValue)) {
      if ((dec.getType().equals("string") && (dec.getAtrib() instanceof Numbers))) {
        this.error((GoValidator.SEMANTIC_ERROR + "não é possível converter string para number"), GoPackage.Literals.DEC_VAR__ATRIBUICAO);
      }
    }
    Greeting _atrib_1 = dec.getAtrib();
    if ((_atrib_1 instanceof Variable)) {
      Greeting _atrib_2 = dec.getAtrib();
      Variable vab = ((Variable) _atrib_2);
      this.checkIfVariableIsDeclarated(vab);
    }
  }
  
  @Check
  public void checkIfVariableIsDeclarated(final Variable variable) {
    boolean _containsKey = GoValidator.variablesDeclarationMap.containsKey(variable.getName());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error((GoValidator.SEMANTIC_ERROR + "variavel não declarada"), GoPackage.Literals.VARIABLE__NAME);
    }
  }
  
  @Check
  public DecFunc addFuncToImplements(final DecFunc dec) {
    return GoValidator.funcImplements.put(dec.getName().toString(), dec);
  }
  
  @Check
  public void checkIfFunctionOverhead(final DecFunc dec) {
    boolean _containsKey = GoValidator.funcImplements.containsKey(dec.getName());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error((GoValidator.SEMANTIC_ERROR + "função não declarada"), GoPackage.Literals.CALL_FUNC__NAME_FUNC);
    }
  }
  
  @Check
  public void callFunc(final CallFunc callFunc) {
    boolean _containsKey = GoValidator.funcImplements.containsKey(callFunc.getNameFunc());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error((GoValidator.SEMANTIC_ERROR + "função não declarada"), GoPackage.Literals.CALL_FUNC__NAME_FUNC);
    }
    DecFunc func = GoValidator.funcImplements.get(callFunc.getNameFunc());
    this.checkIfHasEqualTypes(func, callFunc);
  }
  
  /**
   * Verifies the number of parameters and your respoective types between the function declaration
   * and function call
   */
  public void checkIfHasEqualTypes(final DecFunc func, final CallFunc callFunc) {
    int _parametersSize = this.getParametersSize(func.getParam());
    int _parametersSize_1 = this.getParametersSize(callFunc.getParam());
    boolean _notEquals = (_parametersSize != _parametersSize_1);
    if (_notEquals) {
      this.error((GoValidator.SEMANTIC_ERROR + "Diferença entre a quantidade de parâmetros"), GoPackage.Literals.CALL_FUNC__PARAM);
    }
    List<String> functionTypes = this.getParametersType(func.getParam());
    List<String> callTypes = this.getParametersType(callFunc.getParam());
    for (int i = 0; (i < functionTypes.size()); i++) {
      boolean _equals = callTypes.get(i).equals(functionTypes.get(i));
      boolean _not = (!_equals);
      if (_not) {
        String _get = functionTypes.get(i);
        String _plus = ((GoValidator.SEMANTIC_ERROR + "Diferença entre os tipos dos parâmetros. Tipo Esperado: ") + _get);
        String _plus_1 = (_plus + "  Tipo declarado: ");
        String _get_1 = callTypes.get(i);
        String _plus_2 = (_plus_1 + _get_1);
        this.error(_plus_2, GoPackage.Literals.CALL_FUNC__PARAM);
      }
    }
  }
  
  public int getParametersSize(final Params param) {
    List<String> tipos = new ArrayList<String>();
    if (((!Objects.equal(param, null)) && (!Objects.equal(param.getParams(), null)))) {
      EList<String> _params = param.getParams();
      for (final String t : _params) {
        tipos.add(t);
      }
    }
    return tipos.size();
  }
  
  public List<String> getParametersType(final Params param) {
    List<String> tipos = new ArrayList<String>();
    if (((param != null) && (param.getType() != null))) {
      EList<String> _params = param.getParams();
      for (final String id : _params) {
        tipos.add(this.getDecVarType(id));
      }
    }
    return tipos;
  }
  
  public String getDecVarType(final String id) {
    boolean _containsKey = GoValidator.variablesDeclarationMap.containsKey(id);
    boolean _not = (!_containsKey);
    if (_not) {
      this.error((GoValidator.SEMANTIC_ERROR + "variavel não declarada"), GoPackage.Literals.VARIABLE__NAME);
    } else {
      DecVar dec = GoValidator.variablesDeclarationMap.get(id);
      if ((dec instanceof Atrib)) {
        Atrib atrib = ((Atrib) dec);
        return atrib.getType();
      }
    }
    return null;
  }
}

/**
 * generated by Xtext 2.13.0
 */
package org.xtext.go.validation;

import com.google.common.base.Objects;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.go.go.Atrib;
import org.xtext.go.go.AtribVar;
import org.xtext.go.go.CallFunc;
import org.xtext.go.go.DecFunc;
import org.xtext.go.go.DecVar;
import org.xtext.go.go.Decl;
import org.xtext.go.go.GoPackage;
import org.xtext.go.go.Params;
import org.xtext.go.go.impl.ExpressionImpl;
import org.xtext.go.validation.AbstractGoValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GoValidator extends AbstractGoValidator {
  public final static String SEMANTIC_ERROR = "Erro Semântico: ";
  
  public static Map<String, DecFunc> funcImplements = new HashMap<String, DecFunc>();
  
  public static Map<String, List<DecVar>> variablesDeclarationMap = new HashMap<String, List<DecVar>>();
  
  @Check
  public void checkGreetingStartsWithCapital(final AtribVar g) {
    int _size = g.getAtrb().size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      int _size_1 = g.getVars().size();
      int _size_2 = g.getAtrb().size();
      boolean _lessThan = (_size_1 < _size_2);
      if (_lessThan) {
        this.error("número de atribuições maior que variaveis", GoPackage.Literals.DEC_VARS__VARS);
      } else {
        int _size_3 = g.getVars().size();
        int _size_4 = g.getAtrb().size();
        boolean _greaterThan_1 = (_size_3 > _size_4);
        if (_greaterThan_1) {
          this.error("número de atribuições menor que variaveis", GoPackage.Literals.DEC_VARS__VARS);
        }
      }
    }
  }
  
  public boolean checkIfCallFuncIdExists(final String funcName) {
    boolean out = false;
    DecFunc arr = GoValidator.funcImplements.get(funcName);
    boolean _notEquals = (!Objects.equal(arr, null));
    if (_notEquals) {
      out = true;
    }
    return out;
  }
  
  /**
   * This function add in the map all the variables in the source code
   */
  @Check
  public Boolean addVariableDeclarations(final DecVar dec) {
    boolean _xifexpression = false;
    AtribVar _assignment = dec.getAssignment();
    if ((_assignment instanceof Decl)) {
      this.addAtribVarInMap(dec.getAssignment());
    } else {
      boolean _xifexpression_1 = false;
      Decl _declaration = dec.getDeclaration();
      if ((_declaration instanceof AtribVar)) {
        _xifexpression_1 = this.addDeclarionVarInMap(dec.getDeclaration());
      } else {
        boolean _xifexpression_2 = false;
        Atrib _atribuicao = dec.getAtribuicao();
        if ((_atribuicao instanceof Atrib)) {
          _xifexpression_2 = this.addAtribuicaoVarInMap(dec.getAtribuicao());
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return Boolean.valueOf(_xifexpression);
  }
  
  public void addAtribVarInMap(final AtribVar atrib) {
    EList<String> _vars = atrib.getVars();
    for (final String id : _vars) {
      {
        String _string = id.toString();
        ArrayList<DecVar> _arrayList = new ArrayList<DecVar>();
        GoValidator.variablesDeclarationMap.put(_string, _arrayList);
        GoValidator.variablesDeclarationMap.get(id.toString()).add(((DecVar) atrib));
      }
    }
  }
  
  public boolean addDeclarionVarInMap(final Decl dec) {
    boolean _xblockexpression = false;
    {
      String _string = dec.getName().toString();
      ArrayList<DecVar> _arrayList = new ArrayList<DecVar>();
      GoValidator.variablesDeclarationMap.put(_string, _arrayList);
      _xblockexpression = GoValidator.variablesDeclarationMap.get(dec.getName().toString()).add(((DecVar) dec));
    }
    return _xblockexpression;
  }
  
  public boolean addAtribuicaoVarInMap(final Atrib dec) {
    boolean _xblockexpression = false;
    {
      String _string = dec.getName().toString();
      ArrayList<DecVar> _arrayList = new ArrayList<DecVar>();
      GoValidator.variablesDeclarationMap.put(_string, _arrayList);
      _xblockexpression = GoValidator.variablesDeclarationMap.get(dec.getName().toString()).add(((DecVar) dec));
    }
    return _xblockexpression;
  }
  
  @Check
  public Object checkArithmeticExp(final ExpressionImpl exp) {
    return null;
  }
  
  @Check
  public Object checkLiteralsType(final Type typeNumber, final Type typeBoolean, final Type typeString) {
    return null;
  }
  
  @Check
  public Object checkExistingTypes() {
    return null;
  }
  
  @Check
  public Object checkAbstractions() {
    return null;
  }
  
  @Check
  public Object checkVariableUses() {
    return null;
  }
  
  @Check
  public Object atribuitionComands() {
    return null;
  }
  
  @Check
  public Object checkFunctions() {
    return null;
  }
  
  @Check
  public Object checkBooleanExpressions() {
    return null;
  }
  
  @Check
  public Object checkSwitch() {
    return null;
  }
  
  @Check
  public DecFunc addFuncToImplements(final DecFunc dec) {
    return GoValidator.funcImplements.put(dec.getName().toString(), dec);
  }
  
  @Check
  public void callFunc(final CallFunc callFunc) {
    boolean _containsKey = GoValidator.funcImplements.containsKey(callFunc.getNameFunc());
    boolean _not = (!_containsKey);
    if (_not) {
      this.error((GoValidator.SEMANTIC_ERROR + "função não declarada"), GoPackage.Literals.CALL_FUNC__NAME_FUNC);
    }
    DecFunc func = GoValidator.funcImplements.get(callFunc.getNameFunc());
    this.checkIfHasEqualTypes(func, callFunc);
  }
  
  public List<String> getParametersType(final Params param) {
    List<String> tipos = new ArrayList<String>();
    if (((!Objects.equal(param, null)) && (!Objects.equal(param.getType(), null)))) {
      EList<String> _type = param.getType();
      for (final String t : _type) {
        tipos.add(t);
      }
    }
    return tipos;
  }
  
  /**
   * Verifies the number of parameters and your respoective types between the function declaration
   * and function call
   */
  public void checkIfHasEqualTypes(final DecFunc func, final CallFunc callFunc) {
    List<String> functionTypes = this.getParametersType(func.getParam());
    List<String> callTypes = this.getParametersType(callFunc.getParam());
    int _parametersSize = this.getParametersSize(func.getParam());
    int _parametersSize_1 = this.getParametersSize(callFunc.getParam());
    boolean _notEquals = (_parametersSize != _parametersSize_1);
    if (_notEquals) {
      this.error((GoValidator.SEMANTIC_ERROR + "Diferença entre a quantidade de parâmetros"), GoPackage.Literals.CALL_FUNC__PARAM);
    }
    for (int i = 0; (i < functionTypes.size()); i++) {
      boolean _equals = callTypes.get(i).equals(functionTypes.get(i));
      boolean _not = (!_equals);
      if (_not) {
        String _get = functionTypes.get(i);
        String _plus = ((GoValidator.SEMANTIC_ERROR + "Diferença entre os tipos dos parâmetros. Tipo Esperado: ") + _get);
        String _plus_1 = (_plus + "  Tipo declarado: ");
        String _get_1 = callTypes.get(i);
        String _plus_2 = (_plus_1 + _get_1);
        this.error(_plus_2, GoPackage.Literals.CALL_FUNC__PARAM);
      }
    }
  }
  
  public int getParametersSize(final Params param) {
    List<String> tipos = new ArrayList<String>();
    if (((!Objects.equal(param, null)) && (!Objects.equal(param.getParams(), null)))) {
      EList<String> _params = param.getParams();
      for (final String t : _params) {
        tipos.add(t);
      }
    }
    return tipos.size();
  }
}

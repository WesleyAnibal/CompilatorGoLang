/*
 * generated by Xtext 2.13.0
 */
package org.xtext.go.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GoGrammarAccess extends AbstractGrammarElementFinder {
	
	public class GoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.Go");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsGreetingParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//Go:
		//	elements+=Greeting*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=Greeting*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//Greeting
		public RuleCall getElementsGreetingParserRuleCall_0() { return cElementsGreetingParserRuleCall_0; }
	}
	public class GreetingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.Greeting");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEntityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDecFuncParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cEOLTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Greeting:
		//	DataType | Entity | DecFunc | EOL;
		@Override public ParserRule getRule() { return rule; }
		
		//DataType | Entity | DecFunc | EOL
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DataType
		public RuleCall getDataTypeParserRuleCall_0() { return cDataTypeParserRuleCall_0; }
		
		//Entity
		public RuleCall getEntityParserRuleCall_1() { return cEntityParserRuleCall_1; }
		
		//DecFunc
		public RuleCall getDecFuncParserRuleCall_2() { return cDecFuncParserRuleCall_2; }
		
		//EOL
		public RuleCall getEOLTerminalRuleCall_3() { return cEOLTerminalRuleCall_3; }
	}
	public class DecFuncElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.DecFunc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFUNCParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParameterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterIDTerminalRuleCall_3_0 = (RuleCall)cParameterAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cParameterAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cParameterIDTerminalRuleCall_4_1_0 = (RuleCall)cParameterAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//DecFunc:
		//	FUNC name=ID "(" parameter=ID? ("," parameter=ID)* ")" "{" "}";
		@Override public ParserRule getRule() { return rule; }
		
		//FUNC name=ID "(" parameter=ID? ("," parameter=ID)* ")" "{" "}"
		public Group getGroup() { return cGroup; }
		
		//FUNC
		public RuleCall getFUNCParserRuleCall_0() { return cFUNCParserRuleCall_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//parameter=ID?
		public Assignment getParameterAssignment_3() { return cParameterAssignment_3; }
		
		//ID
		public RuleCall getParameterIDTerminalRuleCall_3_0() { return cParameterIDTerminalRuleCall_3_0; }
		
		//("," parameter=ID)*
		public Group getGroup_4() { return cGroup_4; }
		
		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }
		
		//parameter=ID
		public Assignment getParameterAssignment_4_1() { return cParameterAssignment_4_1; }
		
		//ID
		public RuleCall getParameterIDTerminalRuleCall_4_1_0() { return cParameterIDTerminalRuleCall_4_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class TerminalsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.Terminals");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCASEParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCHANParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCONSTParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCONTINUEParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cELSEParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cIFParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cFORParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cFUNCParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cIMPORTParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cRETURNParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cPACKAGEParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cRANGEParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//Terminals:
		//	BREAK | CASE | CHAN | CONST | CONTINUE | ELSE | IF | FOR | FUNC | IMPORT | RETURN | PACKAGE | RANGE;
		@Override public ParserRule getRule() { return rule; }
		
		//BREAK | CASE | CHAN | CONST | CONTINUE | ELSE | IF | FOR | FUNC | IMPORT | RETURN | PACKAGE | RANGE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_0() { return cBREAKParserRuleCall_0; }
		
		//CASE
		public RuleCall getCASEParserRuleCall_1() { return cCASEParserRuleCall_1; }
		
		//CHAN
		public RuleCall getCHANParserRuleCall_2() { return cCHANParserRuleCall_2; }
		
		//CONST
		public RuleCall getCONSTParserRuleCall_3() { return cCONSTParserRuleCall_3; }
		
		//CONTINUE
		public RuleCall getCONTINUEParserRuleCall_4() { return cCONTINUEParserRuleCall_4; }
		
		//ELSE
		public RuleCall getELSEParserRuleCall_5() { return cELSEParserRuleCall_5; }
		
		//IF
		public RuleCall getIFParserRuleCall_6() { return cIFParserRuleCall_6; }
		
		//FOR
		public RuleCall getFORParserRuleCall_7() { return cFORParserRuleCall_7; }
		
		//FUNC
		public RuleCall getFUNCParserRuleCall_8() { return cFUNCParserRuleCall_8; }
		
		//IMPORT
		public RuleCall getIMPORTParserRuleCall_9() { return cIMPORTParserRuleCall_9; }
		
		//RETURN
		public RuleCall getRETURNParserRuleCall_10() { return cRETURNParserRuleCall_10; }
		
		//PACKAGE
		public RuleCall getPACKAGEParserRuleCall_11() { return cPACKAGEParserRuleCall_11; }
		
		//RANGE
		public RuleCall getRANGEParserRuleCall_12() { return cRANGEParserRuleCall_12; }
	}
	public class BREAKElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.BREAK");
		private final Keyword cBreakKeyword = (Keyword)rule.eContents().get(1);
		
		//BREAK:
		//	"break";
		@Override public ParserRule getRule() { return rule; }
		
		//"break"
		public Keyword getBreakKeyword() { return cBreakKeyword; }
	}
	public class CASEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.CASE");
		private final Keyword cCaseKeyword = (Keyword)rule.eContents().get(1);
		
		//CASE:
		//	"case";
		@Override public ParserRule getRule() { return rule; }
		
		//"case"
		public Keyword getCaseKeyword() { return cCaseKeyword; }
	}
	public class CHANElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.CHAN");
		private final Keyword cChanKeyword = (Keyword)rule.eContents().get(1);
		
		//CHAN:
		//	"chan";
		@Override public ParserRule getRule() { return rule; }
		
		//"chan"
		public Keyword getChanKeyword() { return cChanKeyword; }
	}
	public class CONSTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.CONST");
		private final Keyword cConstKeyword = (Keyword)rule.eContents().get(1);
		
		//CONST:
		//	"const";
		@Override public ParserRule getRule() { return rule; }
		
		//"const"
		public Keyword getConstKeyword() { return cConstKeyword; }
	}
	public class CONTINUEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.CONTINUE");
		private final Keyword cContinueKeyword = (Keyword)rule.eContents().get(1);
		
		//CONTINUE:
		//	"continue";
		@Override public ParserRule getRule() { return rule; }
		
		//"continue"
		public Keyword getContinueKeyword() { return cContinueKeyword; }
	}
	public class ELSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.ELSE");
		private final Keyword cElseKeyword = (Keyword)rule.eContents().get(1);
		
		//ELSE:
		//	"else";
		@Override public ParserRule getRule() { return rule; }
		
		//"else"
		public Keyword getElseKeyword() { return cElseKeyword; }
	}
	public class FORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.FOR");
		private final Keyword cForKeyword = (Keyword)rule.eContents().get(1);
		
		//FOR:
		//	"for";
		@Override public ParserRule getRule() { return rule; }
		
		//"for"
		public Keyword getForKeyword() { return cForKeyword; }
	}
	public class FUNCElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.FUNC");
		private final Keyword cFuncKeyword = (Keyword)rule.eContents().get(1);
		
		//FUNC:
		//	"func";
		@Override public ParserRule getRule() { return rule; }
		
		//"func"
		public Keyword getFuncKeyword() { return cFuncKeyword; }
	}
	public class IFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.IF");
		private final Keyword cIfKeyword = (Keyword)rule.eContents().get(1);
		
		//IF:
		//	"if";
		@Override public ParserRule getRule() { return rule; }
		
		//"if"
		public Keyword getIfKeyword() { return cIfKeyword; }
	}
	public class IMPORTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.IMPORT");
		private final Keyword cImportKeyword = (Keyword)rule.eContents().get(1);
		
		//IMPORT:
		//	"import";
		@Override public ParserRule getRule() { return rule; }
		
		//"import"
		public Keyword getImportKeyword() { return cImportKeyword; }
	}
	public class RETURNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.RETURN");
		private final Keyword cReturnKeyword = (Keyword)rule.eContents().get(1);
		
		//RETURN:
		//	"return";
		@Override public ParserRule getRule() { return rule; }
		
		//"return"
		public Keyword getReturnKeyword() { return cReturnKeyword; }
	}
	public class PACKAGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.PACKAGE");
		private final Keyword cPackageKeyword = (Keyword)rule.eContents().get(1);
		
		//PACKAGE:
		//	"package";
		@Override public ParserRule getRule() { return rule; }
		
		//"package"
		public Keyword getPackageKeyword() { return cPackageKeyword; }
	}
	public class TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.TYPE");
		private final Keyword cTypeKeyword = (Keyword)rule.eContents().get(1);
		
		//TYPE:
		//	"type";
		@Override public ParserRule getRule() { return rule; }
		
		//"type"
		public Keyword getTypeKeyword() { return cTypeKeyword; }
	}
	public class VARElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.VAR");
		private final Keyword cVarKeyword = (Keyword)rule.eContents().get(1);
		
		//VAR:
		//	"var";
		@Override public ParserRule getRule() { return rule; }
		
		//"var"
		public Keyword getVarKeyword() { return cVarKeyword; }
	}
	public class SWITCHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.SWITCH");
		private final Keyword cSwitchKeyword = (Keyword)rule.eContents().get(1);
		
		//SWITCH:
		//	"switch";
		@Override public ParserRule getRule() { return rule; }
		
		//"switch"
		public Keyword getSwitchKeyword() { return cSwitchKeyword; }
	}
	public class STRUCTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.STRUCT");
		private final Keyword cStructKeyword = (Keyword)rule.eContents().get(1);
		
		//STRUCT:
		//	"struct";
		@Override public ParserRule getRule() { return rule; }
		
		//"struct"
		public Keyword getStructKeyword() { return cStructKeyword; }
	}
	public class RANGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.RANGE");
		private final Keyword cRangeKeyword = (Keyword)rule.eContents().get(1);
		
		//RANGE:
		//	"range";
		@Override public ParserRule getRule() { return rule; }
		
		//"range"
		public Keyword getRangeKeyword() { return cRangeKeyword; }
	}
	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.Entity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPrintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Entity:
		//	'print' '(' name=ID ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'print' '(' name=ID ')'
		public Group getGroup() { return cGroup; }
		
		//'print'
		public Keyword getPrintKeyword_0() { return cPrintKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class DataTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.DataType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//DataType:
		//	'datatype' name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'datatype' name=ID
		public Group getGroup() { return cGroup; }
		
		//'datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	
	
	private final GoElements pGo;
	private final GreetingElements pGreeting;
	private final TerminalRule tEOL;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tNEWLINE;
	private final DecFuncElements pDecFunc;
	private final TerminalsElements pTerminals;
	private final BREAKElements pBREAK;
	private final CASEElements pCASE;
	private final CHANElements pCHAN;
	private final CONSTElements pCONST;
	private final CONTINUEElements pCONTINUE;
	private final ELSEElements pELSE;
	private final FORElements pFOR;
	private final FUNCElements pFUNC;
	private final IFElements pIF;
	private final IMPORTElements pIMPORT;
	private final RETURNElements pRETURN;
	private final PACKAGEElements pPACKAGE;
	private final TYPEElements pTYPE;
	private final VARElements pVAR;
	private final SWITCHElements pSWITCH;
	private final STRUCTElements pSTRUCT;
	private final RANGEElements pRANGE;
	private final EntityElements pEntity;
	private final DataTypeElements pDataType;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GoGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pGo = new GoElements();
		this.pGreeting = new GreetingElements();
		this.tEOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.EOL");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.SL_COMMENT");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.go.Go.NEWLINE");
		this.pDecFunc = new DecFuncElements();
		this.pTerminals = new TerminalsElements();
		this.pBREAK = new BREAKElements();
		this.pCASE = new CASEElements();
		this.pCHAN = new CHANElements();
		this.pCONST = new CONSTElements();
		this.pCONTINUE = new CONTINUEElements();
		this.pELSE = new ELSEElements();
		this.pFOR = new FORElements();
		this.pFUNC = new FUNCElements();
		this.pIF = new IFElements();
		this.pIMPORT = new IMPORTElements();
		this.pRETURN = new RETURNElements();
		this.pPACKAGE = new PACKAGEElements();
		this.pTYPE = new TYPEElements();
		this.pVAR = new VARElements();
		this.pSWITCH = new SWITCHElements();
		this.pSTRUCT = new STRUCTElements();
		this.pRANGE = new RANGEElements();
		this.pEntity = new EntityElements();
		this.pDataType = new DataTypeElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.go.Go".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Go:
	//	elements+=Greeting*;
	public GoElements getGoAccess() {
		return pGo;
	}
	
	public ParserRule getGoRule() {
		return getGoAccess().getRule();
	}
	
	//Greeting:
	//	DataType | Entity | DecFunc | EOL;
	public GreetingElements getGreetingAccess() {
		return pGreeting;
	}
	
	public ParserRule getGreetingRule() {
		return getGreetingAccess().getRule();
	}
	
	//terminal EOL:
	//	NEWLINE | SL_COMMENT;
	public TerminalRule getEOLRule() {
		return tEOL;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal NEWLINE:
	//	'\r'? '\n';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//DecFunc:
	//	FUNC name=ID "(" parameter=ID? ("," parameter=ID)* ")" "{" "}";
	public DecFuncElements getDecFuncAccess() {
		return pDecFunc;
	}
	
	public ParserRule getDecFuncRule() {
		return getDecFuncAccess().getRule();
	}
	
	//Terminals:
	//	BREAK | CASE | CHAN | CONST | CONTINUE | ELSE | IF | FOR | FUNC | IMPORT | RETURN | PACKAGE | RANGE;
	public TerminalsElements getTerminalsAccess() {
		return pTerminals;
	}
	
	public ParserRule getTerminalsRule() {
		return getTerminalsAccess().getRule();
	}
	
	//BREAK:
	//	"break";
	public BREAKElements getBREAKAccess() {
		return pBREAK;
	}
	
	public ParserRule getBREAKRule() {
		return getBREAKAccess().getRule();
	}
	
	//CASE:
	//	"case";
	public CASEElements getCASEAccess() {
		return pCASE;
	}
	
	public ParserRule getCASERule() {
		return getCASEAccess().getRule();
	}
	
	//CHAN:
	//	"chan";
	public CHANElements getCHANAccess() {
		return pCHAN;
	}
	
	public ParserRule getCHANRule() {
		return getCHANAccess().getRule();
	}
	
	//CONST:
	//	"const";
	public CONSTElements getCONSTAccess() {
		return pCONST;
	}
	
	public ParserRule getCONSTRule() {
		return getCONSTAccess().getRule();
	}
	
	//CONTINUE:
	//	"continue";
	public CONTINUEElements getCONTINUEAccess() {
		return pCONTINUE;
	}
	
	public ParserRule getCONTINUERule() {
		return getCONTINUEAccess().getRule();
	}
	
	//ELSE:
	//	"else";
	public ELSEElements getELSEAccess() {
		return pELSE;
	}
	
	public ParserRule getELSERule() {
		return getELSEAccess().getRule();
	}
	
	//FOR:
	//	"for";
	public FORElements getFORAccess() {
		return pFOR;
	}
	
	public ParserRule getFORRule() {
		return getFORAccess().getRule();
	}
	
	//FUNC:
	//	"func";
	public FUNCElements getFUNCAccess() {
		return pFUNC;
	}
	
	public ParserRule getFUNCRule() {
		return getFUNCAccess().getRule();
	}
	
	//IF:
	//	"if";
	public IFElements getIFAccess() {
		return pIF;
	}
	
	public ParserRule getIFRule() {
		return getIFAccess().getRule();
	}
	
	//IMPORT:
	//	"import";
	public IMPORTElements getIMPORTAccess() {
		return pIMPORT;
	}
	
	public ParserRule getIMPORTRule() {
		return getIMPORTAccess().getRule();
	}
	
	//RETURN:
	//	"return";
	public RETURNElements getRETURNAccess() {
		return pRETURN;
	}
	
	public ParserRule getRETURNRule() {
		return getRETURNAccess().getRule();
	}
	
	//PACKAGE:
	//	"package";
	public PACKAGEElements getPACKAGEAccess() {
		return pPACKAGE;
	}
	
	public ParserRule getPACKAGERule() {
		return getPACKAGEAccess().getRule();
	}
	
	//TYPE:
	//	"type";
	public TYPEElements getTYPEAccess() {
		return pTYPE;
	}
	
	public ParserRule getTYPERule() {
		return getTYPEAccess().getRule();
	}
	
	//VAR:
	//	"var";
	public VARElements getVARAccess() {
		return pVAR;
	}
	
	public ParserRule getVARRule() {
		return getVARAccess().getRule();
	}
	
	//SWITCH:
	//	"switch";
	public SWITCHElements getSWITCHAccess() {
		return pSWITCH;
	}
	
	public ParserRule getSWITCHRule() {
		return getSWITCHAccess().getRule();
	}
	
	//STRUCT:
	//	"struct";
	public STRUCTElements getSTRUCTAccess() {
		return pSTRUCT;
	}
	
	public ParserRule getSTRUCTRule() {
		return getSTRUCTAccess().getRule();
	}
	
	//RANGE:
	//	"range";
	public RANGEElements getRANGEAccess() {
		return pRANGE;
	}
	
	public ParserRule getRANGERule() {
		return getRANGEAccess().getRule();
	}
	
	//Entity:
	//	'print' '(' name=ID ')';
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}
	
	//DataType:
	//	'datatype' name=ID;
	public DataTypeElements getDataTypeAccess() {
		return pDataType;
	}
	
	public ParserRule getDataTypeRule() {
		return getDataTypeAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

/*
 * generated by Xtext 2.13.0
 */
package org.xtext.go.validation

import org.eclipse.xtext.validation.Check
import org.xtext.go.go.Go
import org.xtext.go.go.DecVar
import org.xtext.go.go.GoPackage
import org.xtext.go.go.Greeting
import org.xtext.go.go.Decl
import java.util.Map
import java.util.List
import java.util.HashMap
import org.xtext.go.go.DecFunc
import org.xtext.go.go.CallFunc
import java.util.ArrayList
import org.xtext.go.go.Expression
import org.xtext.go.go.impl.ExpressionImpl
import org.xtext.go.go.impl.LiteralImpl
import java.lang.reflect.Type
import org.xtext.go.go.impl.DecVarImpl
import org.xtext.go.go.AtribVar
import org.xtext.go.go.impl.CallFuncImpl
import org.xtext.go.go.Params
import java.sql.Types

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoValidator extends AbstractGoValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GoPackage.Literals.GREETING__ NAME,
//					INVALID_NAME)
//		}
//	}

	public static final String SEMANTIC_ERROR = "Erro Semântico: ";
	
	public static Map<String,DecFunc> funcImplements = new HashMap<String, DecFunc>();
	public static Map<String, List<DecVar>> variablesDeclarationMap     = new HashMap<String, List<DecVar>>();
	

	@Check
	def checkGreetingStartsWithCapital(DecVar g) {
		if(g.atrb.size() > 0){
			
			if(g.vars.size() < g.atrb.size()){
				error("número de atribuições maior que variaveis", GoPackage.Literals.DEC_VARS__VARS);
			}else if(g.vars.size() > g.atrb.size()){
				error("número de atribuições menor que variaveis", GoPackage.Literals.DEC_VARS__VARS);
			}
		}
	}
	
	def checkIfCallFuncIsValid(CallFunc cf){
		
		if(checkIfCallFuncIdExists(cf.nameFunc.toString())){
			error("Identificador da função não existe", GoPackage.Literals.CALL_FUNC__NAME_FUNC);
		}
		
	}
	
	def boolean checkIfCallFuncIdExists(String funcName){
		
		var out = false; 
		var arr = funcImplements.get(funcName);
		if(arr != null){
			out = true;
		} 
		return out;
		
	}
	
	/**
	 * This function add in the map all the variables in the source code
	 */
	@Check
	def addVariableDeclarations(DecVarImpl dec){
		if(dec.assignment != null){
			addAtribVarInMap(dec.assignment);
		}else if(dec.declaration != null){
			addDeclarionVarInMap(dec.declaration);
		}
	}
	
	
	def addAtribVarInMap(AtribVar atrib){
		for(String id : atrib.vars){
			variablesDeclarationMap.put(id.toString(), new ArrayList());
			variablesDeclarationMap.get(id.toString()).add(atrib as DecVar)
		}
	}
	
	def addDeclarionVarInMap(Decl dec){
		variablesDeclarationMap.put(dec.name.toString(), new ArrayList());
		variablesDeclarationMap.get(dec.name.toString()).add(dec as DecVar);
	}
	
	// escopo comum
	// obs.: algumas classes nao foram geradas como a Opers, entao,
		// para contornar esse erro, na gramatica de expression, colocamos atributos como sum e sub em expression, para acessar esse tipo de tratamento.
	@Check 
	def checkArithmeticExp(ExpressionImpl exp) {
		
		// TO DO
	}
	
	@Check 
	def checkLiteralsType(Type typeNumber, Type typeBoolean, Type typeString) {
		//TO DO
	}
	
	@Check
	def checkExistingTypes() {
		//TO DO	
	}
	
	@Check
	def checkAbstractions() {
		//TO DO
	}
	
	@Check
	def checkVariableUses() {
		//TO DO
	}
	
	@Check
	def atribuitionComands() {
		//TO DO
	}
	
	
	// escopo C
	@Check
	def checkFunctions() {
		//TO DO
	}
	
	@Check
	def checkBooleanExpressions() {
		//TO DO
	}
	
	@Check
	def checkSwitch() {
		//TO DO
	}
		
	@Check
	def addFuncToImplements(DecFunc dec){
		funcImplements.put(dec.name.toString(), dec);
	}
	
	@Check
	def callFunc(CallFunc callFunc){
		if (!funcImplements.containsKey(callFunc.nameFunc) ){
			error(SEMANTIC_ERROR + "função não declarada",GoPackage.Literals.CALL_FUNC__NAME_FUNC);
		} 
		var DecFunc func = funcImplements.get(callFunc.nameFunc);
		if(callFunc.param.params.size() != func.param.params.size()){
				error(SEMANTIC_ERROR + "Diferença entre a quantidade de parâmetros" ,GoPackage.Literals.CALL_FUNC__PARAM);
			
		}

	}
	
//	def getTiposParametros(Params call){
//		var List<String> tiposParametros = new ArrayList<String>();
//		if(call.tiposParametros != null){
//			for(Types type : param. )
//		}
//	}

	
}

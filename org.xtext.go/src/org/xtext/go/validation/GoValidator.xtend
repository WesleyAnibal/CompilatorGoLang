/*
 * generated by Xtext 2.13.0
 */
package org.xtext.go.validation

import org.eclipse.xtext.validation.Check
import org.xtext.go.go.Go
import org.xtext.go.go.DecVar
import org.xtext.go.go.GoPackage
import org.xtext.go.go.Greeting
import org.xtext.go.go.Decl
import java.util.Map
import java.util.List
import java.util.HashMap
import org.xtext.go.go.DecFunc
import org.xtext.go.go.CallFunc
import java.util.ArrayList
import org.xtext.go.go.Expression
import org.xtext.go.go.impl.ExpressionImpl
import org.xtext.go.go.impl.LiteralImpl
import java.lang.reflect.Type
import org.xtext.go.go.impl.DecVarImpl
import org.xtext.go.go.AtribVar
import org.xtext.go.go.impl.CallFuncImpl
import org.xtext.go.go.Params
import java.sql.Types
import org.xtext.go.go.Atrib
import org.xtext.go.go.impl.AtribImpl
import org.xtext.go.go.Variable
import org.xtext.go.go.TypeValue
import org.xtext.go.go.Atri
import org.xtext.go.go.Numbers

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoValidator extends AbstractGoValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GoPackage.Literals.GREETING__ NAME,
//					INVALID_NAME)
//		}
//	}

	public static final String SEMANTIC_ERROR = "Erro Semântico: ";
	
	public static Map<String,DecFunc> funcImplements = new HashMap<String, DecFunc>();
	public static Map<String, DecVar> variablesDeclarationMap     = new HashMap<String, DecVar>();
	

	@Check
	def checkGreetingStartsWithCapital(AtribVar g) {
		if(g.atrb.size() > 0){
			
			if(g.vars.size() < g.atrb.size()){
				error("número de atribuições maior que variaveis", GoPackage.Literals.DEC_VARS__VARS);
			}else if(g.vars.size() > g.atrb.size()){
				error("número de atribuições menor que variaveis", GoPackage.Literals.DEC_VARS__VARS);
			}
		}
	}
	
	def boolean checkIfCallFuncIdExists(String funcName){
		
		var out = false; 
		var arr = funcImplements.get(funcName);
		if(arr != null){
			out = true;
		} 
		return out;
		
	}
	
	/**
	 * This function add in the map all the variables in the source code
	 */
	@Check
	def addVariableDeclarations(DecVar dec){
		if(dec.assignment instanceof Decl){
			addAtribVarInMap(dec.assignment);
		}else if(dec.declaration instanceof AtribVar){
			addDeclarionVarInMap(dec.declaration);
		} else if(dec.atribuicao instanceof Atrib){
			addAtribuicaoVarInMap(dec.atribuicao);
		}
	}
	
	
	def addAtribVarInMap(AtribVar atrib){
		for(String id : atrib.vars){
			variablesDeclarationMap.put(id.toString(), atrib as DecVar);
		}
	}
	
	def addDeclarionVarInMap(Decl dec){
		variablesDeclarationMap.put(dec.name.toString(), dec as DecVar);
	}
	
	def addAtribuicaoVarInMap(Atrib dec){
		
		checkTypeDeclarationAtrib(dec);		
		

		variablesDeclarationMap.put(dec.name.toString(), dec as DecVar);
	}
	
	def checkTypeDeclarationAtrib (Atrib dec) {
		if(dec.atrib instanceof TypeValue){
			if(dec.type.equals("string") &&  dec.atrib instanceof Numbers){
				error(SEMANTIC_ERROR + "não é possível converter string para number" , GoPackage.Literals.DEC_VAR__ATRIBUICAO);
			
			}
		}
		if(dec.atrib instanceof Variable){
			var Variable vab = dec.atrib as Variable;
			checkIfVariableIsDeclarated(vab);
		}
		
	}

	
	// escopo comum
	// obs.: algumas classes nao foram geradas como a Opers, entao,
		// para contornar esse erro, na gramatica de expression, colocamos atributos como sum e sub em expression, para acessar esse tipo de tratamento.
	
	
	@Check
	def checkIfVariableIsDeclarated(Variable variable){
		if(!variablesDeclarationMap.containsKey(variable.name)){
			error(SEMANTIC_ERROR + "variavel não declarada", GoPackage.Literals.VARIABLE__NAME);
		}
		
	}
		
	@Check
	def addFuncToImplements(DecFunc dec){
		funcImplements.put(dec.name.toString(), dec);			

	}
	
	@Check 
	def checkIfFunctionOverhead(DecFunc dec){
		if (!funcImplements.containsKey(dec.name) ){
			error(SEMANTIC_ERROR + "função não declarada",GoPackage.Literals.CALL_FUNC__NAME_FUNC);
		} 
	}
	
	@Check
	def callFunc(CallFunc callFunc){
		if (!funcImplements.containsKey(callFunc.nameFunc) ){
			error(SEMANTIC_ERROR + "função não declarada",GoPackage.Literals.CALL_FUNC__NAME_FUNC);
		} 
		var DecFunc func = funcImplements.get(callFunc.nameFunc);
		
		checkIfHasEqualTypes(func, callFunc);
	}
	

	
	/**
	 * Verifies the number of parameters and your respoective types between the function declaration
	 * and function call
	 */
	def checkIfHasEqualTypes(DecFunc func, CallFunc callFunc){
		if(getParametersSize(func.param) != getParametersSize(callFunc.param)){
			error(SEMANTIC_ERROR + "Diferença entre a quantidade de parâmetros" ,GoPackage.Literals.CALL_FUNC__PARAM);
		}
		
		var List<String> functionTypes = getParametersType(func.param);
		var List<String> callTypes = getParametersType(callFunc.param);
		
		
		
		for(var int i = 0; i < functionTypes.size() ; i++){
			if(!callTypes.get(i).equals(functionTypes.get(i))){
				error(SEMANTIC_ERROR + "Diferença entre os tipos dos parâmetros. Tipo Esperado: " + functionTypes.get(i) 
							+ "  Tipo declarado: " + callTypes.get(i) ,GoPackage.Literals.CALL_FUNC__PARAM
				);
			}
		}
	}

	def getParametersSize(Params param){
		var List<String> tipos = new ArrayList<String>();
		if(param != null && param.params != null){
			for(String t : param.params){
				tipos.add(t);
			}
		}
		return tipos.size(); 
			
	}
	
	def getParametersType(Params param){
		
		var List<String> tipos = new ArrayList<String>();
		if(param !== null && param.type !== null){
			for(String id : param.params){
				tipos.add(getDecVarType(id))
			}
		}
		return tipos; 
			
	}
	
	def getDecVarType(String id){
		if(!variablesDeclarationMap.containsKey(id)){
			error(SEMANTIC_ERROR + "variavel não declarada", GoPackage.Literals.VARIABLE__NAME);
		}else{
			var DecVar dec = variablesDeclarationMap.get(id);
			if(dec instanceof Atrib){
				var Atrib atrib = dec as Atrib; 
				return atrib.type;
			}
		}
		
		
	}
	
	
	
	
}
